const std = @import("std");

/// gen-ffi: Generate .fy FFI binding files from a simple declaration format.
///
/// Input format (.ffi file):
///   Lines starting with '#' are comments.
///   First non-comment line: library path (e.g., "libraylib.dylib")
///   Subsequent lines: function declarations in format:
///     <name> <sig>
///   Where <sig> is the sig: format (e.g., "iii:v", "d:d", ":v")
///
/// Example input (raylib.ffi):
///   libraylib.dylib
///   InitWindow iii:v
///   CloseWindow :v
///   WindowShouldClose :i
///   BeginDrawing :v
///   EndDrawing :v
///   ClearBackground 4:v
///   DrawCircle iif4:v
///
/// Output (.fy):
///   ( Auto-generated FFI bindings )
///   "libraylib.dylib" dl-open
///   : _lib ;
///   : InitWindow _lib "InitWindow" dl-sym sig: iii:v ;
///   ...

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    const args = try std.process.argsAlloc(allocator);
    defer std.process.argsFree(allocator, args);

    if (args.len < 2) {
        const stderr = std.io.getStdErr().writer();
        try stderr.print("Usage: gen-ffi <input.ffi> [output.fy]\n", .{});
        try stderr.print("\nGenerates .fy FFI bindings from a declaration file.\n", .{});
        try stderr.print("\nInput format:\n", .{});
        try stderr.print("  First non-comment line: library path\n", .{});
        try stderr.print("  Subsequent lines: <function_name> <signature>\n", .{});
        try stderr.print("  Comments start with #\n", .{});
        try stderr.print("\nSignature format: <arg_types>:<return_type>\n", .{});
        try stderr.print("  i = integer/pointer    f = float32    d = float64\n", .{});
        try stderr.print("  4 = 4-byte struct      p = pointer    v = void\n", .{});
        std.process.exit(1);
    }

    const input_path = args[1];

    // Read input file
    const input_file = std.fs.cwd().openFile(input_path, .{}) catch |err| {
        const stderr = std.io.getStdErr().writer();
        try stderr.print("Cannot open input file '{s}': {}\n", .{ input_path, err });
        std.process.exit(1);
        unreachable;
    };
    defer input_file.close();
    const input = try input_file.reader().readAllAlloc(allocator, 10 * 1024 * 1024);
    defer allocator.free(input);

    // Determine output path
    const output_path = if (args.len >= 3) args[2] else blk: {
        // Replace .ffi with .fy, or append .fy
        if (std.mem.endsWith(u8, input_path, ".ffi")) {
            const base = input_path[0 .. input_path.len - 4];
            const out = try allocator.alloc(u8, base.len + 3);
            @memcpy(out[0..base.len], base);
            @memcpy(out[base.len..], ".fy");
            break :blk @as([]const u8, out);
        } else {
            const out = try allocator.alloc(u8, input_path.len + 3);
            @memcpy(out[0..input_path.len], input_path);
            @memcpy(out[input_path.len..], ".fy");
            break :blk @as([]const u8, out);
        }
    };

    // Parse input
    var library_path: ?[]const u8 = null;
    const Function = struct {
        name: []const u8,
        sig: []const u8,
    };
    var functions = std.ArrayList(Function).init(allocator);
    defer functions.deinit();

    var lines = std.mem.splitScalar(u8, input, '\n');
    while (lines.next()) |line| {
        const trimmed = std.mem.trim(u8, line, " \t\r");
        if (trimmed.len == 0) continue;
        if (trimmed[0] == '#') continue;

        if (library_path == null) {
            library_path = trimmed;
            continue;
        }

        // Parse "name sig"
        var parts = std.mem.splitScalar(u8, trimmed, ' ');
        const name = parts.next() orelse continue;
        // Skip extra whitespace
        var sig: ?[]const u8 = null;
        while (parts.next()) |part| {
            const s = std.mem.trim(u8, part, " \t");
            if (s.len > 0) {
                sig = s;
                break;
            }
        }
        if (sig) |s| {
            try functions.append(.{ .name = name, .sig = s });
        }
    }

    if (library_path == null) {
        const stderr = std.io.getStdErr().writer();
        try stderr.print("Error: No library path found in input file\n", .{});
        std.process.exit(1);
    }

    // Generate output
    const output_file = try std.fs.cwd().createFile(output_path, .{});
    defer output_file.close();
    const w = output_file.writer();

    try w.print("( Auto-generated FFI bindings for {s} )\n", .{library_path.?});
    try w.print("( Generated by gen-ffi from {s} )\n\n", .{input_path});
    try w.print("constant _lib \"{s}\" dl-open ;\n", .{library_path.?});

    // Emit constant fptr for each function, then a thin wrapper with sig:
    for (functions.items) |func| {
        try w.print("constant _{s} _lib \"{s}\" dl-sym ;\n", .{ func.name, func.name });
    }
    try w.print("\n", .{});
    for (functions.items) |func| {
        try w.print(": {s}  _{s} sig: {s} ;\n", .{ func.name, func.name, func.sig });
    }

    try w.print("\n( End of auto-generated bindings )\n", .{});

    const stderr = std.io.getStdErr().writer();
    try stderr.print("Generated {s} ({d} functions)\n", .{ output_path, functions.items.len });
}
